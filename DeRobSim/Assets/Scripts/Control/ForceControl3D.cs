using System.Collections;
using System.Collections.Generic;
using System; 
using System.Text; 
using UnityEngine;
using Unity.Mathematics;
// Matlab Libraries
using MathWorks.MATLAB.NET.Arrays; // import from MWArray.dll
using MatlabForceControlLib;       // import the custom control Matlab Library
// For debugging
using NVIDIA.Flex;


//++++++++++++++++++++++++++++++++++++++++++++++ REMEMBER +++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+ THE CURRENT IMPLEMENTATION ONLY TAKES INTO ACCOUNT THE DEFORMABLE OBJECT THAT IS ATTACHED TO THE CONTROLLER +
//+ TODO: IMPLEMENT IT TO TAKE INTO ACCOUNT MORE THAN ONE DEFORMABLE OBJECT                                     +
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
public class ForceControl3D : MonoBehaviour
{
    #region Properties
    //--------- Public ---------
    [Header("Agents")]
    public List<Agent> listAgents = new List<Agent>();              // Agents for being controlled
    [Header("Agent Poses")]
    public List<Transform> agentPose = new List<Transform>();       // Current pose (position and rotation) of the agents
    public List<Transform> agentDest = new List<Transform>();       // Destination pose of the agents

    // TODO: Change to be adaptable to multiple or different deformable objects
    [Header("Deformable Object")]
    public FlexActor DefObj;                                        // Deformable object to be controlled

    //+++ Control params +++

    // Delta Time
    [Header("Delta Time")]
    public float dt =  0.033f;

    // Control gains
    [Header("Control Gains")]
    public float kh = 1.0f;                                 // Deformation Gain
    public float kg = 2.0f;                                 // Deformation Correction Gain 
    public float ks = 0.5f;                                 // Scale control Gain
    public float kgm = 0.5f;                                // Position Gain
    public float kth = 0.8f;                                // Orientation Gain
    public float kF = 1.0f;                                 // Force Gain
    
    // Force Controller (barrier function) specific gains
    [Header("CBF Gains")]
    public float katt = 0.0f;                               // Agents destination attraction gain
    public float krep = 1.0f;                               // Mesh nodes' repulsive force gain
    public float cbf_alpha = 1.0f;                          // Barrier function alpha modifier gain

    [Header("Destination Modifiers")]
    public float dest_scale = 1.0f;                         // It scales up or down the destination shape
    public float dest_rotation = 0.0f;                      // It rotates the destination shape

    // Object physical characteristics
    [Header("Object Physical Parameters")]
    public float E = 210.0f;                                // Object's Young Modulus
    public float nu = 0.3f;                                 // Object's Poisson Ratio
    public float yield_stress = 290.0f;                     // Object's Yield Stress (stress value when the deformation becomes plastic)
    public float SF = 1.5f;                                 // Object's Safety Factor (used for not reaching the yield stress during the control)

    // Control Initialization
    [Header("Control Initialization")]
    public bool start_control = false;                       // Boolean used for starting the control

    // Debug variables
    [Header("Debug")]
    public bool draw_destiny = true;                         // Boolean used for drawing the destination of the object
    public bool log_simulation = false;                      // Boolean used for saving the control parameters
    public string log_fileName = "ForceControl3D_log";       // Filename used for the log file
    public string log_filePath = "SimulationLogs";           // Filepath used for the log file

    public float saveInterval = 0.25F;

    //--------- Private ---------
    private int n_agents;
    private float2x2 Rot90M = new float2x2(0.0f, -1.0f, 1.0f, 0.0f); // 90 deg rotation matrix to be used in the control
    
    //--- Controller custom params ---
    // Tetrahedral mesh poses
    private int n_tetverts;
    private int n_tets;
    private Vector3[] meshVertex_origin; // Tetrahedral mesh initial pose
    private Vector3[] meshVertex_currPose; // Tetrahedral mesh current pose
    private Vector3[] meshVertex_prevPose; // Tetrahedral mesh previous pose
    private Vector4[] meshTetrahedrons; // Tetrahedra of the tetrahedral mesh (generated by matlab)+
    // Triangular mesh poses
    private int n_triangverts;
    private Vector3[] triangVertex_origin; // Triangular mesh vertices' initial pose
    // Stress Tensor
    private double[,] prev_stressTensor; // Stress tensor of the previous instance (n_tetverts,6)
    // Mesh of the deformable object
    private Mesh defObj_mesh;
    //----
    private MatlabForceControlLib.MatlabForceControlLib controllerLib = new MatlabForceControlLib.MatlabForceControlLib();  // Object that uses the Matlab Library for the control algorithm
    private Vector3[] agentVel;
    private bool agentsGrabbed = false;
    private bool agentsActivated = true;
    private float currPose_error = float.PositiveInfinity; // Determine the system current error
    private DebugLogger simLogger;  // Object used for logging the simulation
    private int n_matlabParams = 16; // Number of outputs received from matlab when debugging

    #endregion Properties

    #region Main Methods

    void Awake()
    {
        // Time.deltaTime --> returns the time (in seconds) it took to complete the last frame
        //dt = Time.deltaTime;
    }

    // Start is called before the first frame update
    void Start()
    {
        // Prepare the control
        n_agents = listAgents.Count;

        for(int i = 0; i < n_agents; ++i){
            // Modify the agent dt to coordinate the whole control
            listAgents[i].set_dt(dt);
        }

        // Prepare the deformable object mesh for the control
        InstantiateMeshParams();


        // Drawing
        if(draw_destiny)
            DrawDestination();

        // Resize of the agents acceleration
        agentVel = new Vector3[n_agents];

        // Agent activation for using them
        ActivateAgents();

        // Debug log
        if(simLogger != null)
            PrepareDebugLogger();
    }

    // Update is called once per frame
    void Update()
    {
        // ------- Drawing part ------- 
        // We draw the destiny if it has not been drawn
        if(draw_destiny)
            DrawDestination();

        // ------- Agent Grab -------
        if(start_control && !agentsGrabbed)
            AllAgentsGrab();

        // ------- Control part -------
        if(start_control){
            if(!agentsActivated)
                ActivateAgents();
            
            // We update the tetrahedral mesh vertices' positions
            UpdateDefObjMesh(); // First we need to update our triangular mesh positions based on the deformable object's internal mesh
            UpdateTetMeshVerts(); // Then we can update the tetrahedral mesh vertices' positions

            // We call the main control algorithm
            MWNumericArray velocities;
            
            if(log_simulation){ // If we want to log the simulation
                // We get the whole list of results
                MWArray[] control_results = controllerLib.ForceControl3D_Debug(n_matlabParams,Vector32MWNumericArray(meshVertex_origin),Vector32MWNumericArray(meshVertex_currPose),Vector32MWNumericArray(meshVertex_prevPose),Transform2Positions(agentPose),Transform2Positions(agentDest),Vector42MWNumericArray(meshTetrahedrons),new MWNumericArray(prev_stressTensor),E,nu,yield_stress,SF,kF,katt,krep,cbf_alpha,kh,kg,ks,kgm,kth,dest_scale,dest_rotation);

                // First we filter from the control results the velocities that are going to be sent to the agents
                velocities = (MWNumericArray)control_results.GetValue(0);

                // Secondly we filter from the control results the currently computed stress tensor
                MWNumericArray stress = (MWNumericArray)control_results.GetValue(1);
                prev_stressTensor = (double[,])stress.ToArray(MWArrayComponent.Real);

                // If we do not have any debugLogger created we create it
                if(simLogger == null){
                    simLogger = gameObject.AddComponent<DebugLogger>();
                    PrepareDebugLogger();
                }

                // We update the Dictionary with the matlab params
                UpdateMatlabParams(control_results);

                // We save the logs on the file
                simLogger.saveData();
                

            } else { // Else we only retrieve the velocities and the current stress values
                MWArray[] control_results = controllerLib.ForceControl3D(2,Vector32MWNumericArray(meshVertex_origin),Vector32MWNumericArray(meshVertex_currPose),Vector32MWNumericArray(meshVertex_prevPose),Transform2Positions(agentPose),Transform2Positions(agentDest),Vector42MWNumericArray(meshTetrahedrons),new MWNumericArray(prev_stressTensor),E,nu,yield_stress,SF,kF,katt,krep,cbf_alpha,kh,kg,ks,kgm,kth,dest_scale,dest_rotation);

                // First we filter from the control results the velocities that are going to be sent to the agents
                velocities = (MWNumericArray)control_results.GetValue(0);

                // Secondly we filter from the control results the currently computed stress tensor
                MWNumericArray stress = (MWNumericArray)control_results.GetValue(1);
                prev_stressTensor = (double[,])stress.ToArray(MWArrayComponent.Real);
            }
            // We convert the output to a Vector3 to use it as velocities within the agents
            MWNumericArray2Vels(velocities);

            // We send the velocities to the agents
            SendVels();

        }

        if(!start_control && agentsGrabbed)
            AllAgentsRelease();
        
        // If we are not performing any control we stop all the agents
        if(!start_control)
            StopAgents();

    }
    #endregion Main Methods

    #region Custom methods

    // ------- Setting Up the Controller -------
    MWNumericArray Transform2Positions(List<Transform> Transformations){
        float[,] positions = new float[3,n_agents];

        for(int i = 0; i < n_agents; ++i){
            positions[0,i] = Transformations[i].position.x;
            positions[1,i] = Transformations[i].position.y;
            positions[2,i] = Transformations[i].position.z;
        }

        return new MWNumericArray(positions);
    }

    MWNumericArray AgentPose2Positions(List<Agent.pose> Poses){
        float[,] positions = new float[3,n_agents];

        for(int i = 0; i < n_agents; ++i){
            positions[0,i] = Poses[i].position.x;
            positions[1,i] = Poses[i].position.y;
            positions[2,i] = Poses[i].position.z;
        }

        return new MWNumericArray(positions);
    }

    MWNumericArray Vector32MWNumericArray(Vector3[] vector3s){
        float[,] positions = new float[3,vector3s.Length];

        for(int i = 0; i < vector3s.Length; ++i){
            positions[0,i] = vector3s[i].x;
            positions[1,i] = vector3s[i].y;
            positions[2,i] = vector3s[i].z;
        }

        return new MWNumericArray(positions);
    }

    MWNumericArray Vector32ElementsArray(Vector3[] vector3s){
        float[,] positions = new float[vector3s.Length,3];

        for(int i = 0; i < vector3s.Length; ++i){
            positions[i,0] = vector3s[i].x;
            positions[i,1] = vector3s[i].y;
            positions[i,2] = vector3s[i].z;
        }

        return new MWNumericArray(positions);
    }

    MWNumericArray Vector42MWNumericArray(Vector4[] vector4s){
        float[,] positions = new float[4,vector4s.Length];

        for(int i = 0; i < vector4s.Length; ++i){
            positions[0,i] = vector4s[i].x;
            positions[1,i] = vector4s[i].y;
            positions[2,i] = vector4s[i].z;
            positions[3,i] = vector4s[i].w;
        }

        return new MWNumericArray(positions);
    }

    // ------- Controller output Handle -------
    private void MWNumericArray2Vels(MWNumericArray velocities){
        double[,] vels = (double[,])velocities.ToArray(MWArrayComponent.Real);
        for(int i = 0; i < n_agents; ++i)
            agentVel[i] = new Vector3((float)vels[0,i], (float)vels[1,i], (float)vels[2,i]);
    }

    private double[,] MWNumericArray2UnityArray(MWNumericArray matlabArray){
        return (double[,])matlabArray.ToArray(MWArrayComponent.Real);
    }

    private Vector3[] MWNumericArray2Vector3(MWNumericArray matlabArray){
        double[,] array = (double[,])matlabArray.ToArray(MWArrayComponent.Real);
        Vector3[] vector3s = new Vector3[array.GetLength(1)];
        for(int i = 0; i < array.GetLength(1); ++i)
            vector3s[i] = new Vector3((float)array[0,i],  (float)array[1,i], (float)array[2,i]);
        
        return vector3s;
    }
    
    private Vector4[] MWNumericArray2Vector4(MWNumericArray matlabArray){
        double[,] array = (double[,])matlabArray.ToArray(MWArrayComponent.Real);
        Vector4[] vector4s = new Vector4[array.GetLength(1)];
        for(int i = 0; i < array.GetLength(1); ++i)
            vector4s[i] = new Vector4((float)array[0,i],  (float)array[1,i], (float)array[2,i], (float)(array[3,i]));
        
        return vector4s;
    }

    private double MWNumericArray2DoubleScalar(MWNumericArray matlabArray){
        return matlabArray.ToScalarDouble();
    }

    // ------- Agents -------
    private void AllAgentsGrab(){
        foreach(Agent agent in listAgents)
            agent.set_activeGrab(true);
        
        agentsGrabbed = true;
    }
    
    private void AllAgentsRelease(){
        foreach(Agent agent in listAgents)
            agent.set_activeGrab(false);
        
        agentsGrabbed = false;
    }

    private void SendVels(){
        for(int i = 0; i < n_agents; ++i)
            listAgents[i].set_vel(agentVel[i]);
    }

    private void StopAgents(){
        foreach(Agent agent in listAgents){
            if(!agent.isAgentStopped())
                agent.StopAgent();
        }
        
        agentsActivated = false;
    }

    private void ActivateAgents(){
        foreach(Agent agent in listAgents){
            if(agent.isAgentStopped())
                agent.ActivateAgent();
        }

        agentsActivated = true;
    }

    // ------- Mesh -------
    private void InstantiateMeshParams(){
        // We update the deformable object mesh
        UpdateDefObjMesh();

        // We get the number of vertices in the triangular mesh
        n_triangverts = defObj_mesh.vertexCount;

        // We get the triangular mesh vertices' positions in world coordinates
        triangVertex_origin = GetTriangMeshVertices(defObj_mesh, DefObj.gameObject.transform);

        // We generate the tetrahedral mesh
        GenerateTetMesh(triangVertex_origin, GetTrianglesAsVector3(defObj_mesh));

        // We set the previous and the current tetrahedral mesh vertices' poses as the origin
        // We return a copy to ensure that we do not modify the origin vector
        meshVertex_currPose = (Vector3[])meshVertex_origin.Clone();
        meshVertex_prevPose = (Vector3[])meshVertex_origin.Clone();

        // We set up the stress tensor
        prev_stressTensor = new double[n_tetverts,6]; // This initializes by default all its values to 0

    }

    // Updates the defObj_mesh property values based on the deformable object attached to the controller
    private void UpdateDefObjMesh(){
            // We get the mesh of the deformable object
            SkinnedMeshRenderer defObj_Skin = DefObj.gameObject.GetComponent<SkinnedMeshRenderer>();
            MeshFilter defObj_MeshFilter = DefObj.gameObject.GetComponent<MeshFilter>();
            defObj_mesh = new Mesh();

            // Store the mesh
            if(defObj_Skin != null)
                defObj_Skin.BakeMesh(defObj_mesh);
            else
                defObj_mesh = defObj_MeshFilter.mesh;
    }

    // Returns the world coordinates of the mesh vertices' passed as an argument
    private Vector3[] GetTriangMeshVertices(Mesh mesh, Transform mesh_transform){
        // We generate the local space mesh vertices' array
        Vector3[] vertices = mesh.vertices;
        // We transform the vertices from local coordinates to world coordinates
        mesh_transform.TransformPoints(vertices);

        return vertices;
    }

    // Returns the triangles of the triangular mesh in an organized way where (x,y,z) represents each of the vertices of the triangle
    private Vector3[] GetTrianglesAsVector3(Mesh mesh){
        int[] mesh_triangles = mesh.triangles;
        Vector3[] triangles = new Vector3[(int)(mesh_triangles.Length/3)];

        for(int i = 0; i < triangles.Length; i += 3)
        {
                int idx0 = mesh_triangles[i];
                int idx1 = mesh_triangles[i + 1];
                int idx2 = mesh_triangles[i + 2];

                triangles[(int)(i/3)] = new Vector3(idx0,  // Vertex 0
                                                    idx1,  // Vertex 1
                                                    idx2); // Vertex 2 
        }
        return triangles;
    }

    // Generates and stores a tetrahedral mesh through the matlab library
    private void GenerateTetMesh(Vector3[] vertexOrigins, Vector3[] mesh_triangles){
        // We call the matlab library method to generate the tetrahedral mesh
        int n_outputs = 3; // The method returns 3 outputs (new mesh nodes' positions, the generated tetrahedra, the volumes of the tetrahedra)
        MWArray[] tet_results = controllerLib.GenerateTetrahedrons(n_outputs,Vector32ElementsArray(vertexOrigins),Vector32ElementsArray(mesh_triangles));

        // We handle the outputs
        meshVertex_origin = MWNumericArray2Vector3((MWNumericArray)tet_results.GetValue(0));
        meshTetrahedrons = MWNumericArray2Vector4((MWNumericArray)tet_results.GetValue(1));
        // We do not get the last output as it is the tetrahedra's volumes

        // We update the count of tetrahedra and the count of tetrahedral mesh vertices
        n_tetverts = meshVertex_origin.Length;  // Number of tetrahedral mesh vertices
        n_tets = meshTetrahedrons.Length;       // Number of tetrahedra
    }

    // Interpolates and updates the current tetrahedral mesh vertices
    private void UpdateTetMeshVerts(){
        // We update the previous tetrahedral mesh vertices' information
        meshVertex_prevPose = (Vector3[])meshVertex_currPose.Clone();

        // We call the matlab library method to interpolate the new tetrahedral mesh vertices' information
        int n_outputs = 1; // The method returns 1 outputs (new mesh nodes' positions)
        MWArray[] interp_result = controllerLib.InterpolateMeshNodes(n_outputs,Vector32MWNumericArray(triangVertex_origin),Vector32MWNumericArray(GetTriangMeshVertices(defObj_mesh,DefObj.gameObject.transform)),Vector32MWNumericArray(meshVertex_origin));
        meshVertex_currPose = MWNumericArray2Vector3((MWNumericArray)interp_result.GetValue(0));
    }

    // ------- Error Computation -------
    // Computes the overall error of the agents position
    private bool isCloseEnough(float threshold){
        float pose_error = 0.0f;
        bool closeEnough = false;

        for(int i = 0; i < n_agents; ++i)
            pose_error += Vector3.Distance(agentPose[i].position, agentDest[i].position);
        
        currPose_error = pose_error;
        if(pose_error < threshold)
            closeEnough = true;
        
        return closeEnough;
    } 

    // ------- Drawing -------
    private void DrawDestination(){
        for(int i = 0; i < n_agents; ++i){
            if(i+1 >= n_agents)
                Debug.DrawLine(agentDest[i].position, agentDest[0].position,Color.blue);
            else
                Debug.DrawLine(agentDest[i].position, agentDest[i+1].position,Color.blue);
        }
    }

    // ------- Debug -------
    private void PrepareDebugLogger(){
        // We prepare the debug logger
        // We set the filepath
        simLogger.fileName = log_fileName + "_" +DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss") + ".h5";
        simLogger.filePath = log_filePath;

        // We set the saveInterval
        simLogger.updateSaveInterval = saveInterval;

        // We intialize the debug logger
        simLogger.InitializeData();

        // We set the agents
        simLogger.registeredAgents = listAgents;
        // We set the agent destinations
        simLogger.registeredTransforms = agentDest;
        // We set the flexObjects
        simLogger.registeredFlexObjects = new List<FlexActor>(FindObjectsOfType<FlexActor>());

        // We add the dictionary with all the params
        
        // - velocity
        simLogger.registeredMatlabParams.Add("velocity", null);
        // - stress tensor
        simLogger.registeredMatlabParams.Add("stressTensor", null);
        // - U_f
        simLogger.registeredMatlabParams.Add("U_f", null);
        // - U_H
        simLogger.registeredMatlabParams.Add("U_H", null);
        // - U_G
        simLogger.registeredMatlabParams.Add("U_G", null);
        // - U_s
        simLogger.registeredMatlabParams.Add("U_s", null);
        // - U_c
        simLogger.registeredMatlabParams.Add("U_c", null);
        // - U_Hd
        simLogger.registeredMatlabParams.Add("U_Hd", null);
        // - U_cbf
        simLogger.registeredMatlabParams.Add("U_cbf", null);
        // - Positions
        simLogger.registeredMatlabParams.Add("positions", null);
        // - Destinations
        simLogger.registeredMatlabParams.Add("destinations", null);
        // +++++++ ERRORS +++++++
        // - gamma_H
        simLogger.registeredMatlabScalars.Add("gamma_H", Double.NaN);
        // - gamma_G
        simLogger.registeredMatlabScalars.Add("gamma_G", Double.NaN);
        // - eg
        simLogger.registeredMatlabScalars.Add("eg", Double.NaN);
        // - es
        simLogger.registeredMatlabScalars.Add("es", Double.NaN);
        // - eth
        simLogger.registeredMatlabScalars.Add("eth", Double.NaN);
        // - eth_individual
        simLogger.registeredMatlabParams.Add("eth_individual", null);

    }

    private void UpdateMatlabParams(MWArray[] matlabParams){
        // - velocity
        simLogger.registeredMatlabParams["velocity"] = MWNumericArray2Vector3((MWNumericArray)matlabParams.GetValue(0));
        // - stress tensor
        MWNumericArray stress = (MWNumericArray)matlabParams.GetValue(1);
        // simLogger.registeredMatlabParams["stressTensor"] = (double[,])stress.ToArray(MWArrayComponent.Real);
        // - U_f
        simLogger.registeredMatlabParams["U_f"] = MWNumericArray2Vector3((MWNumericArray)matlabParams.GetValue(2));
        // - U_H
        simLogger.registeredMatlabParams["U_H"] = MWNumericArray2Vector3((MWNumericArray)matlabParams.GetValue(3));
        // - U_G
        simLogger.registeredMatlabParams["U_G"] = MWNumericArray2Vector3((MWNumericArray)matlabParams.GetValue(4));
        // - U_s
        simLogger.registeredMatlabParams["U_s"] = MWNumericArray2Vector3((MWNumericArray)matlabParams.GetValue(5));
        // - U_c
        simLogger.registeredMatlabParams["U_c"] = MWNumericArray2Vector3((MWNumericArray)matlabParams.GetValue(6));
        // - U_Hd
        simLogger.registeredMatlabParams["U_Hd"] = MWNumericArray2Vector3((MWNumericArray)matlabParams.GetValue(7));
        // - U_cbf
        simLogger.registeredMatlabParams["U_cbf"] = MWNumericArray2Vector3((MWNumericArray)matlabParams.GetValue(8));
        // - Positions
        simLogger.registeredMatlabParams["positions"] = MWNumericArray2Vector3((MWNumericArray)matlabParams.GetValue(9));
        // - Destinations
        simLogger.registeredMatlabParams["destinations"] = MWNumericArray2Vector3((MWNumericArray)matlabParams.GetValue(10));
        // +++++++ ERRORS +++++++
        // - gamma_H
        simLogger.registeredMatlabScalars["gamma_H"] = MWNumericArray2DoubleScalar((MWNumericArray)matlabParams.GetValue(11));
        // - gamma_G
        simLogger.registeredMatlabScalars["gamma_G"] = MWNumericArray2DoubleScalar((MWNumericArray)matlabParams.GetValue(12));
        // - eg
        simLogger.registeredMatlabScalars["eg"] = MWNumericArray2DoubleScalar((MWNumericArray)matlabParams.GetValue(13));
        // - es
        simLogger.registeredMatlabScalars["es"] = MWNumericArray2DoubleScalar((MWNumericArray)matlabParams.GetValue(14));
        // - eth
        simLogger.registeredMatlabScalars["eth"] = MWNumericArray2DoubleScalar((MWNumericArray)matlabParams.GetValue(15));        
        // - eth_individual
        simLogger.registeredMatlabParams["eth_individual"] = MWNumericArray2Vector3((MWNumericArray)matlabParams.GetValue(16));    

    }


    #endregion Custom methods
}
